# 모터 이상 진동 감지 시스템 (motor_vibration_analysis.py)
## 프로그램 원리 및 로직 상세 설명

---

## 1. 프로그램 개요

### 1.1 목적
모터의 비정상적인 진동을 **실시간으로 감지**하고 분석하는 PyQt5 기반 GUI 애플리케이션입니다.

### 1.2 동작 모드
1. **CSV 파일 재생 모드**: 기존 측정 데이터를 로드하여 분석
2. **실시간 센서 모드**: 센서로부터 직접 데이터를 수집하여 실시간 분석

### 1.3 입출력
- **입력**: WTVB01-485 센서 (Modbus RTU 프로토콜) 또는 CSV 파일
- **출력**: 실시간 그래프, FFT 분석, 경보, 이벤트 로그 (CSV)

---

## 2. 핵심 아키텍처

### 2.1 시스템 구성도
```
┌─────────────────────────────────────────────┐
│         PyQt5 GUI 메인 윈도우               │
├─────────────────────────────────────────────┤
│  ┌──────────────────────────────────────┐  │
│  │  탭1: 신호 표시                       │  │
│  │  (3축 가속도/속도/변위/온도 시계열)   │  │
│  └──────────────────────────────────────┘  │
│  ┌──────────────────────────────────────┐  │
│  │  탭2: FFT 분석                        │  │
│  │  (가속도/속도/변위 주파수 스펙트럼)   │  │
│  └──────────────────────────────────────┘  │
│  ┌──────────────────────────────────────┐  │
│  │  탭3: 임계치 설정                     │  │
│  │  (사용자 조정 가능한 경보 임계값)     │  │
│  └──────────────────────────────────────┘  │
│  ┌──────────────────────────────────────┐  │
│  │  탭4: 이벤트 로그                     │  │
│  │  (경보 이력 및 CSV 내보내기)          │  │
│  └──────────────────────────────────────┘  │
│  ┌──────────────────────────────────────┐  │
│  │  제어 패널                            │  │
│  │  (모드 전환, 센서 연결, 재생 제어)    │  │
│  └──────────────────────────────────────┘  │
└─────────────────────────────────────────────┘
         ↕ (백그라운드 스레드)
┌─────────────────────────────────────────────┐
│     센서 리더 스레드 (SensorReader)         │
│  - Modbus RTU 통신                         │
│  - 주기적 데이터 수집 (기본 200ms)         │
│  - 스레드-안전 큐(deque) 저장              │
└─────────────────────────────────────────────┘
         ↕ (직렬 통신)
┌─────────────────────────────────────────────┐
│    USB-to-RS485 어댑터                      │
│    ↓                                        │
│  WTVB01-485 센서 (Modbus 슬레이브)         │
│  - 3축 가속도 (g)                          │
│  - 3축 진동속도 (mm/s)                     │
│  - 3축 진동변위 (μm)                       │
│  - 3축 주파수 (Hz)                         │
│  - 온도 (°C)                               │
└─────────────────────────────────────────────┘
```

### 2.2 데이터 흐름

#### CSV 파일 재생 모드
```
CSV 파일
  ↓
DataProcessor.load_csv()
  ↓ (pandas 로드)
DataFrame 저장
  ↓
타이머 이벤트 (30fps)
  ↓
update_display()
  ↓ (CSV 인덱스 증가)
get_current_row() / get_window()
  ↓
data_type_convert (문자열 → float)
  ↓
plot 갱신 + FFT 계산 + 임계치 확인
  ↓
GUI 업데이트
```

#### 실시간 센서 모드
```
SensorReader 스레드 시작
  ↓
Modbus RTU 요청 (주기 200ms)
  ↓
Register 읽기
  - 0x0034-0x39: 가속도 (6개 레지스터 = 3축 × 2)
  - 0x003A-0x3F: 진동속도 (6개)
  - 0x0041-0x46: 진동변위 (6개)
  - 0x0044-0x49: 주파수 (6개)
  - 0x0040: 온도 (1개)
  ↓
Raw 값 → Float 변환 (IEEE 754 포맷)
  ↓
데이터 딕셔너리 생성
  ↓
data_queue (deque, 최대 500개) 저장
  ↓
타이머 이벤트 (30fps)
  ↓
update_display()
  ↓
data_queue에서 최근 10개 추출
  ↓
plot 갱신 + FFT 계산 + 임계치 확인
  ↓
GUI 업데이트
```

---

## 3. 핵심 모듈별 상세 로직

### 3.1 ModbusRTU 클래스
**역할**: Modbus RTU 프로토콜을 통한 센서 통신

#### 3.1.1 CRC16 계산
```
입력: 바이트 시퀀스
처리:
  1. CRC 초기값: 0xFFFF
  2. 각 바이트에 대해:
     - CRC와 바이트 XOR
     - 8비트 시프트 및 다항식(0xA001) XOR
  3. 최종 CRC 반환
목적: 데이터 무결성 검증
```

#### 3.1.2 Modbus 요청 프레임 구성
```
요청 프레임 구조:
┌─────────────────────────────────────────────┐
│ 슬레이브 주소 (1B) │ 0x03 함수 (1B)        │
│ 시작 레지스터 (2B) │ 레지스터 수 (2B)     │
│ CRC16 (2B)                                 │
├─────────────────────────────────────────────┤
│ 예: 0x50 0x03 0x00 0x34 0x00 0x06 CRC_LO │
│     (ID=0x50, 함수=읽기, 레지스터=0x34부터 6개)
└─────────────────────────────────────────────┘

응답 프레임 구조:
┌─────────────────────────────────────────────┐
│ 슬레이브 주소 │ 함수 │ 바이트 수 │ 데이터... │ CRC
│ 0x50        │ 0x03 │ 0x0C     │ reg...  │ CRC
└─────────────────────────────────────────────┘
```

#### 3.1.3 레지스터 값 해석
```
센서는 부동소수점을 2개 레지스터 (4바이트)로 저장:

Raw 레지스터: [reg_high, reg_low]
  ↓
변환 과정:
  1. 32비트 정수 구성: (reg_high << 16) | reg_low
  2. IEEE 754 부동소수점 해석: struct.unpack('>f', data)
  
예: [0x3F80, 0x0000] → 1.0 (가속도 1g)
```

### 3.2 SensorReader 클래스 (백그라운드 스레드)
**역할**: 비동기적 센서 데이터 수집

#### 3.2.1 스레드 동작 주기
```
타이밍:
  측정 시작
    ↓ [약 50ms]
  가속도 읽기 (6 레지스터)
    ↓ [약 50ms]
  온도 읽기 (1 레지스터)
    ↓ [약 50ms]
  진동속도 읽기 (6 레지스터)
    ↓ [약 50ms]
  진동변위 읽기 (6 레지스터)
    ↓ [약 50ms]
  주파수 읽기 (6 레지스터)
    ↓ [약 50ms]
  총 약 300ms = 수집 완료
  
  남은 시간 슬립 (interval - 경과시간)
  
반복 주기: 기본 200ms (매초 5회 수집)
```

#### 3.2.2 데이터 큐 관리
```
data_queue = deque(maxlen=500)
  - 최대 500개의 데이터 포인트 저장
  - FIFO: 오래된 데이터 자동 제거
  - 스레드 안전 (GIL 보호)
  
메모리: 약 500개 × 13개 필드 × 8바이트 ≈ 52KB
```

#### 3.2.3 오류 처리
```
센서 읽기 실패 시:
  - 예외 캐치 및 로깅
  - 0.5초 슬립 후 재시도
  - GUI 업데이트는 계속 진행 (정지 안 함)
```

### 3.3 DataProcessor 클래스
**역할**: 센서 데이터 처리 및 분석

#### 3.3.1 FFT (고속 푸리에 변환) 분석
```
목적: 시간 영역 신호 → 주파수 영역 스펙트럼

처리 단계:
  1. 신호 입력: [a1, a2, ..., aN]
  
  2. 창(Window) 함수 적용 (Hann Window)
     w(n) = 0.5 × (1 - cos(2π×n/(N-1)))
     목적: 스펙트럼 누설(leakage) 감소
     windowed_signal = signal × w
  
  3. FFT 계산
     Y = FFT(windowed_signal)  [numpy.fft.rfft 사용]
     rfft: 실수 입력 → 양의 주파수만 출력 (효율성)
  
  4. 진폭 정규화
     magnitude = |Y| / (sum(w) / 2)
     목적: 다양한 신호에 대한 일관된 크기 표현
  
  5. 주파수 축 생성
     freq = fftfreq(N, 1/fs)
     예: fs=10Hz, N=10 → freq=[0, 1, 2, ..., 5]Hz

예시:
  입력: 진동속도 신호 (10개 샘플 @ 10Hz)
  출력: 주파수별 크기 스펙트럼 (0~5Hz)
  해석: 어느 주파수 대역에 진동이 집중되어 있는가?
```

#### 3.3.2 RMS (Root Mean Square) 계산
```
목적: 신호의 실효값 (에너지 수준)

공식: RMS = √(1/N × Σ(x_i²))

해석:
  - 값이 클수록 진동이 강함
  - 임계치 초과 시 경보 발생
  
예: RMS = 0.5g → 정상
   RMS = 2.5g → 경보 (임계치 2.0g 초과)
```

#### 3.3.3 Peak (피크) 계산
```
목적: 신호의 최대 절대값

공식: Peak = max(|x_i|)

해석:
  - 순간적인 최대 진동 크기
  - 충격적인 장애 감지에 유용
```

#### 3.3.4 CSV 로드 및 샘플링 주파수 추정
```
프로세스:
  1. pandas.read_csv() 로드
  2. Time 컬럼 파싱 (시간 문자열)
  3. 연속된 타임스탬프의 시간 차이 계산
  4. 평균 간격으로부터 샘플링 주파수 추정
  
예:
  Time: 10:00:00.100, 10:00:00.200, 10:00:00.300, ...
  간격: 100ms → fs = 1/0.1 = 10Hz
  
용도: FFT 주파수축 생성에 사용
```

### 3.4 MotorVibrationGUI 클래스
**역할**: PyQt5 기반 사용자 인터페이스

#### 3.4.1 4개 탭 구조

**탭1: 신호 표시 (Signals Tab)**
```
2×2 서브플롯:
┌──────────────┬──────────────┐
│  가속도      │  진동속도    │
│  (3축 선형)  │  (3축 선형)  │
├──────────────┼──────────────┤
│  진동변위    │  온도        │
│  (3축 선형)  │  (단축 선형) │
└──────────────┴──────────────┘

데이터 표현:
  - X축: 시간 인덱스 (최근 10개 데이터)
  - Y축: 측정값
  - 색상: X(파란색), Y(초록색), Z(빨간색)
  - 마커: o(원형), s(사각형), ^(삼각형)
```

**탭2: FFT 분석 (FFT Tab)**
```
1×3 서브플롯:
┌──────────────┬──────────────┬──────────────┐
│ 가속도 FFT   │ 속도 FFT     │ 변위 FFT     │
│ (주파수 스펙)│ (주파수 스펙)│ (주파수 스펙)│
└──────────────┴──────────────┴──────────────┘

데이터 표현:
  - X축: 주파수 (Hz)
  - Y축: 진폭 (정규화됨)
  - 색상: X(파란색), Y(초록색), Z(빨간색)
  
해석 예:
  피크가 10Hz에 있음 → 모터 고장(회전 불균형 등)의 신호
```

**탭3: 임계치 설정 (Threshold Tab)**
```
조정 가능한 파라미터:
  1. 가속도 RMS 최대 (기본 2.0g)
  2. 진동속도 피크 최대 (기본 100.0 mm/s)
  3. 진동변위 피크 최대 (기본 500.0 μm)
  4. 온도 최대 (기본 60.0°C)

사용자 조정 → "적용" 버튼 → 즉시 적용
```

**탭4: 이벤트 로그 (Event Log Tab)**
```
테이블 구조:
┌───────────┬──────────┬──────────────┬────────┐
│ 시간      │ 유형     │ 내용         │ 상태   │
├───────────┼──────────┼──────────────┼────────┤
│ 10:30:45  │ 경보     │ 가속도...    │ 이상   │
│ 10:30:50  │ 정보     │ 정상 복귀    │ 정상   │
└───────────┴──────────┴──────────────┴────────┘

기능:
  - 실시간 로그 추가
  - 색상 구분 (이상=빨강)
  - CSV 내보내기
```

#### 3.4.2 모드 전환 로직
```
사용자 선택:
  "CSV 파일" 모드 선택
    ↓
  switch_mode()
    ↓
  센서 관련 버튼 비활성화
  재생/속도 버튼 활성화
  use_sensor = False 설정
  
  "실시간 센서" 모드 선택
    ↓
  switch_mode()
    ↓
  센서 관련 버튼 활성화
  재생/속도 버튼 비활성화
  use_sensor = True 설정
  기존 센서 정지
```

#### 3.4.3 타이머 기반 업데이트 루프
```
초기화:
  QTimer 생성
  timeout 신호 → update_display() 연결
  인터벌: 33ms (약 30fps)

CSV 모드:
  timer.start() (재생 중)
    ↓ [33ms마다]
  current_index += speed
  update_display() 호출
  UI 갱신
  
센서 모드:
  센서 시작 시 timer.start()
    ↓ [33ms마다]
  data_queue에서 최근 데이터 추출
  update_display() 호출
  UI 갱신
```

#### 3.4.4 임계치 확인 로직
```
매 업데이트 마다:
  
  1. RMS 계산 및 확인
     if acc_rms > threshold_acc_rms_max:
       alarm_list.append("가속도 RMS 초과...")
  
  2. 피크 계산 및 확인
     if vel_peak > threshold_vel_peak_max:
       alarm_list.append("진동속도 피크 초과...")
     
     if disp_peak > threshold_disp_peak_max:
       alarm_list.append("진동변위 피크 초과...")
  
  3. 온도 확인
     if temp > threshold_temp_max:
       alarm_list.append("온도 초과...")
  
  4. 경보 처리
     if alarm_list is not empty:
       GUI 경보 표시 (빨강, 노강 배경)
       for each alarm:
         add_log_event("경보", alarm, "이상")
     else:
       GUI 정상 표시 (초록)
```

#### 3.4.5 포트 감지 및 센서 연결
```
포트 감지:
  serial.tools.list_ports.comports()
    ↓
  시스템에 연결된 모든 직렬 포트 열거
  → 콤보박스 표시
  
센서 시작:
  사용자 설정 (포트, 보드율, ID) 입력
  "센서 시작" 클릭
    ↓
  SensorReader 스레드 생성
  stop_event 초기화
  data_queue 초기화
  스레드 시작
  타이머 시작
  
센서 정지:
  "센서 정지" 클릭
    ↓
  stop_event.set() (스레드 루프 종료)
  스레드 조인 (최대 2초 대기)
  타이머 정지
```

---

## 4. 신호 처리 알고리즘

### 4.1 이상 진동 감지 전략

```
단계별 처리:

Step 1: 데이터 수집
  시간 영역: 센서 → Modbus → 파이썬 변수
  
Step 2: 시간 영역 분석
  - RMS: 전체 에너지 수준 확인
  - Peak: 순간 최대값 확인
  
Step 3: 주파수 영역 분석 (FFT)
  - 어느 주파수에 진동이 집중되어 있는가?
  - 정상 대비 새로운 주파수 성분의 출현?
  
Step 4: 임계치 비교
  - 정상: RMS < threshold & Peak < threshold
  - 경고: 하나라도 초과
  
Step 5: 이벤트 로그
  - 경보 발생 → CSV 기록
  - 타임스탬프 + 상세 정보 저장
```

### 4.2 모터 고장 진단 예시

```
시나리오: 모터 베어링 손상

신호 변화:
  1. 고주파 성분 증가 (FFT에서 고주파 피크)
  2. 진동 에너지 증가 (RMS ↑)
  3. 피크값 증가 (충격 발생)
  
감지 프로세스:
  
  시간 영역:           주파수 영역:
  ┌────────┐          ┌──────────┐
  │    ╱╲  │ (RMS ↑) │ ╱╲       │ (고주파 피크)
  │   ╱  ╲ │          │╱  ╲╱╲   │
  │  ╱    ╲│          │         ╲│
  └────────┘          └──────────┘
  
  경보 발생:
  "가속도 RMS 초과: 3.2g > 2.0g"
  "진동속도 피크 초과: 150mm/s > 100mm/s"
```

---

## 5. 주요 특징

### 5.1 멀티스레딩
```
메인 스레드 (GUI):
  - 사용자 이벤트 처리
  - 화면 업데이트
  - 반응성 유지 (UI 블로킹 안 함)

센서 스레드 (백그라운드):
  - 직렬 통신 (시간 소비)
  - Modbus 프로토콜 처리
  - 메인과 독립적 실행
  
동기화:
  - deque: 스레드 안전한 데이터 큐
  - threading.Lock: 필요시 보호
  - stop_event: 안전한 종료 신호
```

### 5.2 실시간 성능
```
타이밍:
  센서 수집:    ~300ms (모든 레지스터)
  GUI 업데이트: 33ms (30fps)
  
결과:
  - 센서 레이턴시: 약 300ms
  - GUI 프레임레이트: 30fps (부드러운 재생)
  - 응답 시간: <100ms (임계치 경보)
```

### 5.3 오류 복구
```
통신 오류 시:
  - 예외 캐치
  - 로깅
  - 자동 재시도
  - GUI 계속 실행
  
데이터 타입 오류:
  - to_float() 함수로 안전한 변환
  - 실패 시 NaN 처리
  - 플롯 계속 진행
```

---

## 6. 확장 가능성

### 6.1 추가 기능 아이디어
1. **기준선 설정**: 정상 상태의 신호 저장 → 편차 비교
2. **머신러닝**: 정상/이상 패턴 학습 → 자동 분류
3. **알람 음향**: 경보 시 소리 재생
4. **이메일 알림**: 심각한 이상 시 통보
5. **클라우드 저장**: 장기 데이터 아카이빙
6. **웹 대시보드**: 원격 모니터링

### 6.2 파라미터 최적화
```
조정 가능한 파라미터:

1. 샘플링 주파수
   - 센서 수집 주기 (interval)
   - 가능한 빠를수록 좋음 (나이퀴스트)
   - 제약: 센서 속도, 통신 대역폭

2. FFT 윈도우 크기
   - 길수록: 주파수 해상도 향상 ↑
   - 짧을수록: 시간 해상도 향상 ↑
   
3. 임계치 값
   - 응용 분야별 달라짐 (모터 타입, 사용 환경)
   - 통계적 학습으로 결정 권장
```

---

## 7. 코드 흐름 요약

### 7.1 초기화
```
1. matplotlib 한글 폰트 설정
2. PyQt5 애플리케이션 생성
3. MotorVibrationGUI 인스턴스 생성
4. UI 구성 (탭, 플롯, 제어판)
5. 타이머 설정
6. 메인 이벤트 루프 시작
```

### 7.2 CSV 모드 실행
```
1. "CSV 파일 로드" 클릭
2. 파일 선택 → load_csv()
3. pandas 로드 + DataProcessor 저장
4. "재생" 클릭 → is_playing = True
5. 타이머 매 33ms:
   current_index 증가
   → update_display()
   → CSV 행 추출 → 타입 변환
   → 플롯/FFT/임계치 처리
   → GUI 갱신
6. 종료: "일시정지" 또는 창 닫기
```

### 7.3 센서 모드 실행
```
1. 모드 선택: "실시간 센서"
2. 포트/보드율/ID 설정
3. "센서 시작" 클릭 → toggle_sensor()
4. SensorReader 스레드 시작
5. 백그라운드에서 200ms 주기로:
   - Modbus 요청
   - Register 읽기
   - Float 변환
   - data_queue에 저장
6. 메인스레드 타이머 매 33ms:
   - data_queue 접근
   - 최근 데이터 추출
   - 플롯/FFT/임계치 처리
   - GUI 갱신
7. "센서 정지" 클릭 → 스레드 종료
```

---

## 8. 결론

이 프로그램은 **멀티스레딩 + 신호 처리 + 실시간 GUI**를 결합한 포괄적인 모터 진동 감시 시스템입니다.

**핵심 원리**:
- 센서 데이터 → 시간 영역 분석 (RMS/Peak)
- 신호 처리 (FFT) → 주파수 영역 분석
- 임계치 비교 → 경보 생성
- 비동기 처리 → 실시간 반응성

**사용 사례**:
- 모터 베어링 상태 모니터링
- 회전 기계 고장 진단
- 예방 정비 (Predictive Maintenance)

